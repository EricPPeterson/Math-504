##hw 6
##problem 2
##part b


n <- sample(1:100,2)
rowz <- max(n)
colz <- min(n)
vals <- sample(1:1000, rowz * colz, replace = T)
m <- matrix(data = vals, nrow = rowz, ncol = colz)

GramSchmidt <- function(mat, tol = 1e-10){
  
  #error checking
  stopifnot(is.numeric(mat), is.matrix(mat))
  
  m <- nrow(mat)
  n <- ncol(mat)
  if(m < n){stop ("Number of Rows must be greater than number of columns.")}
  
  ##run algo
  Q <- matrix(data = 0, nrow = m, ncol = n)
  R <- matrix(data = 0, nrow = n, ncol = n)
    
    for (k in 1:n){
    Q[,k] <- mat[,k]
    
    if (k > 1){
      for(i in 1:(k - 1)){  
        R[i,k] <- t(Q[,i]) %*% Q[,k]
        Q[, k] <- Q[, k] - R[i, k] * Q[, i]
      }    
    }
    R[k, k] <- norm(as.matrix(Q[, k]), type = "F")
    
    ##check for linear dependence. will return zero vector if dependence exists.
    if(R[k,k] < tol){stop("Check for linear dependence of vectors.")}
    
    Q[, k] <- Q[, k]/R[k, k]
  }
  return(list (Q = Q, R = R))
}

m.orth <- GramSchmidt(m)

########################################################################
########################################################################

##problem 3
##part a
pima <- read.csv("C:/Users/eric/Desktop/GTown Stats/math 504/HW6/pima.csv")
attach(pima)
x <- pima[,1:8]
y <- pima[,9]
## y = (b0 + b1x1 + b2x2 + b3x3 + b4x4 + b5x5 + b6x6 + b7x7 + b8x8)
## create initial hyperplane

hyper.plane <- function(beta, X){
  ## creates vectors to hold values
  over.under <- matrix(data = 1, nrow = nrow(X), ncol = 1)
  y <- matrix(data = NA, nrow = nrow(X), ncol = 1)
  n <- nrow(X)
  
  ## function to create y values
  for (i in 1:n){
  y[i,] <- (beta[1] * X[i,1]) + (beta[2] * X[i,2]) + (beta[3] * X[i,3]) + (beta[4] * X[i,4]) + (beta[5] * X[i,5]) + (beta[6] * X[i,6]) + (beta[7] * X[i,7]) + (beta[8] * X[i,8]) + beta[9]  
  }
  
  ## function to check/turn y value into one of two classes 
  for (j in 1:n){
  if (y[j,1] < 0) {over.under[j,1] = -1}
  
  }
  ##this should deal with anything that lands on the hyperplane by making it 
  ## only < 0. anything == 0 should be classified as one then, over the 
  ##hyperplane.
  
  return(list(total = y,class = over.under))
}

b <- c(1,1,1,1,1,1,1,1,1)
values <- hyper.plane(beta = b, X = x)

##error fucntion. counts total mis-counted points
##and total error.
e.func <- function(vec, Y){
  E <- matrix(data = NA, nrow = length(Y), ncol = 1)
  n <- length(Y)
  
  for(j in 1:n){
    if(vec[j,1] == Y[j]) { E[j,1] = 0
    } else if(vec[j,1] != Y[j] & Y[j] == -1) {
      E[j,1] = -1 
    } else {
      E[j,1] = 1
    }
  }
  H <- hyper.plane(beta = b,X = x)
  tot.err <- -sum(E * H$total)
  return(list(miscalc = E, total.error = tot.err))
}

err <- e.func(values$class,y)

##F(b) = sum_false(y.i)(b0 + b1x1 + b2x2 + b3x3 + b4x4 + b5x5 + b6x6 + b7x7 + b8x8)
grad.F <- function(mat, resp, e){
  grad.vec <- matrix(data = NA, nrow = ncol(mat)+1, ncol = 1)  
  
  m <- resp

  for (i in 1:(ncol(mat)+1)){
    if (i == 1){n <- rep(1,nrow(mat))}
    if (i > 1){
      n <- mat[,(i-1)]
    } 
    grad.vec[i,1] <- -sum(m * n * e)
  }
  return(grad.vec)
}

dB <- grad.F(mat = x, resp = y, e = err$miscalc)

##part b
steep.D <- function(beta, resp, preds, tol = 1e-2){
  error.matrix <- matrix(data = NA, nrow = 1, ncol = 1)
  beta.matrix <- matrix(data = NA, nrow = 1e5, ncol = 9)
  gX <- 1
  b <- beta
  x <- preds
  y <- resp
  
  while(gX > tol){
  ## initial values
  alpha <- 1
  J <- hyper.plane(beta = b,X = x)
  E <- e.func(J$class,y)$total.error 
  dB <- grad.F(mat = x, resp = y, e = E)
  gX <- sqrt(sum(dB^2))
  pX <- -dB/gX
  
  ## set new point
  new.b <- b + alpha * pX
  J.new <- hyper.plane(beta = new.b, X = x)
  new.E <- e.func(J.new$class,y)$total.error 
  
  while(new.E > E){
    alpha <- alpha/2
    new.b <- b + alpha * pX
    J.new <- hyper.plane(beta = new.b, X = x)
    new.E <- e.func(J.new$class,y)
  }
  if(abs(new.E) < 0){stop("Algo Converged.")}
  b <- new.b
  E <- new.E
  error.matrix <- rbind(error.matrix,E)
  beta.matrix[iter,] <- b
  alpha <- 1
  cat(error.matrix[iter,],"\n")
  cat(gX,"\n")
  }
  return(error.matrix)
}

b <- rep(1,9)
R <- steep.D(beta = b, resp = y, preds = x)
